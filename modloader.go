package main

import (
	"MT-GO/database"
	"MT-GO/tools"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/goccy/go-json"
)

type Game struct {
	NameSpace       string
	ModNameNoSpaces string
	Advanced        struct {
		CustomRoutes bool
	}
	Config map[string]interface{}
}

//var usesRoutes bool

const (
	MTGO_USER_MODS = "%s\"MT-GO/user/mods/%s\""
	MTGO_SERVER    = "\"MT-GO/server\""
	MODNAME_MOD    = "%s.Mod()"
)

func main() {
	// Get the path of the "mods" folder in the same directory as the executable.

	wd, err := os.Getwd()

	modDir := filepath.Join(wd, "user", "mods")
	fmt.Println("Mod directory:", modDir)

	// List all subdirectories in the "mods" folder.
	modSubDirs, err := tools.GetDirectoriesFrom(modDir)
	if err != nil {
		fmt.Println("Error listing subdirectories in the 'mods' folder:", err)
		return
	}

	// Create an array to store the mod imports and function calls.
	modImports := []string{"	\"fmt\"", "	\"time\""}
	modCalls := make([]string, 0)

	//var modAdvanced []string
	var modConfig *database.ModInfo

	if len(modSubDirs) == 0 {
		modCalls = append(modCalls, "fmt.Println(\"Found 0 mods. Canceling\")")
	} else {
		for _, name := range modSubDirs {
			fmt.Println("Checking directory:", name)

			// Check if there's a "mod-info.json" file in the subdirectory.
			ModInfoPath := filepath.Join(modDir, name, "mod-info.json")
			if !tools.FileExist(ModInfoPath) {
				fmt.Println("Did not find 'mod-info.json' in:", name, ", continuing...")
				continue
			}

			// Read and parse the mod-info.json file.
			data := tools.GetJSONRawMessage(ModInfoPath)

			if err := json.Unmarshal(data, &modConfig); err != nil {
				fmt.Printf("Error parsing mod-info.json in %s: %v\n", name, err)
				continue
			}

			// Construct the mod import and function call with alias.
			modImport := fmt.Sprintf(MTGO_USER_MODS, modConfig.ModNameNoSpaces, modConfig.NameSpace)
			modCall := fmt.Sprintf(MODNAME_MOD, modConfig.ModNameNoSpaces)

			fmt.Println("Added imports:", modImport)
			fmt.Println("Added function calls:", modCall)

			// Append the import and function call to the arrays.
			modImports = append(modImports, modImport)
			modCalls = append(modCalls, modCall)

			if modConfig.Advanced.CustomRoutes {
				modAdvanced := make([]string, 0)
				modAdvancedIns := fmt.Sprintf("routes := %s.GetRoutes()\nfor route, handler := range routes {\n    server.AddMainRoute(route, handler)\n}", modConfig.ModNameNoSpaces)

				modAdvanced = append(modAdvanced, modAdvancedIns)
				modImports = append(modImports, MTGO_SERVER)

				fmt.Println("Added Advanced calls:", modAdvancedIns)
			}

		}
	}

	// Debugging: Print the generated import and function call statements.
	//fmt.Println("Generated import statements:")
	//fmt.Println(strings.Join(modImports, "\t"))

	//fmt.Println("Generated function call statements:")
	//fmt.Println(strings.Join(modCalls, "\t"))

	// Update the "mods.go" file.
	modFile := filepath.Join(modDir, "mods.go")
	fmt.Println("Updating 'mods.go' file:", modFile)
	err = updateModsFile(modFile, modImports, modCalls)
	if err != nil {
		fmt.Println("Error updating mods.go:", err)
		return
	}

	exeDir, err := os.Executable()
	if err != nil {
		fmt.Println("Error getting the executable path:", err)
		return
	}

	// Start the main Go instance in a new cmd instance.
	mainGoFile := filepath.Join(filepath.Dir(exeDir), "server.go")
	fmt.Println("Starting main Go instance:", mainGoFile)
	cmd := exec.Command("cmd", "/c", "start", "cmd", "/k", "go run "+"server.go")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	// Run the new cmd instance to start the main Go program.
	if err := cmd.Run(); err != nil {
		fmt.Println("Error starting the main Go instance:", err)
		return
	}

	// Close the updater executable.
	fmt.Println("Updater finished.")
	os.Exit(1)

}

func updateModsFile(filePath string, imports []string, calls []string) error {
	// Create the new content with updated imports and function calls.

	newContent := []byte(fmt.Sprintf(
		`
    // THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MANUALLY EDIT.
    package mods

    import (
        %s
    )

    var startTime time.Time

    func Init() {
        fmt.Println("\n\nInitializing ModLoader...")
        startTime = time.Now()
        main()
    }

    func main() {
    	%s
        
		endTime := time.Now()
        fmt.Printf("Done! Finished loading mods in %%s\n\n", endTime.Sub(startTime))
    }`,
		strings.Join(imports, "\n"),
		strings.Join(calls, "\n"),
	))

	// Write the updated content to "mods.go" or create the file if it doesn't exist.
	err := os.WriteFile(filePath, newContent, os.ModePerm)
	if err != nil {
		return err
	}

	return nil
}
