package main

import (
	"MT-GO/tools"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/goccy/go-json"
)

type Game struct {
	NameSpace       string
	ModNameNoSpaces string
	Advanced        struct {
		CustomRoutes bool
	}
	Config map[string]interface{}
}

//var usesRoutes bool

func main() {
	// Get the path of the "mods" folder in the same directory as the executable.

	wd, err := os.Getwd()

	modDir := filepath.Join(wd, "user", "mods")
	fmt.Println("Mod directory:", modDir)

	// List all subdirectories in the "mods" folder.
	modSubDirs, err := tools.GetDirectoriesFrom(modDir)
	if err != nil {
		fmt.Println("Error listing subdirectories in the 'mods' folder:", err)
		return
	}

	// Create an array to store the mod imports and function calls.
	modImports := []string{"	\"fmt\"", "	\"time\""}
	modCalls := make([]string, 0)

	//var modAdvanced []string
	var modConfig *Game

	// If there are no mods, add "fmt" and "time" to the imports.

	if len(modSubDirs) == 0 {
		modCalls = append(modCalls, "fmt.Println(\"Found 0 mods. Canceling\")")
	} else {
		for _, name := range modSubDirs {
			fmt.Println("Checking directory:", name)

			// Check if there's a "mod-info.json" file in the subdirectory.
			ModInfoPath := filepath.Join(modDir, name, "mod-info.json")
			if _, err := os.Stat(ModInfoPath); err == nil {
				fmt.Println("Found 'mod-info.json' in:", name)

				// Read and parse the mod-info.json file.
				data := tools.GetJSONRawMessage(ModInfoPath)

				if err := json.Unmarshal(data, &modConfig); err != nil {
					fmt.Printf("Error parsing mod-info.json in %s: %v\n", name, err)
					continue
				}
				fmt.Printf(modConfig.ModNameNoSpaces)
				fmt.Printf(modConfig.NameSpace)

				// Construct the mod import and function call with alias.
				modImport := fmt.Sprintf("%s\"MT-GO/user/mods/%s\"", modConfig.ModNameNoSpaces, modConfig.NameSpace)
				modCall := fmt.Sprintf("    %s.Mod()", modConfig.ModNameNoSpaces)

				fmt.Println("Added imports:", modImport)
				fmt.Println("Added function calls:", modCall)

				// Append the import and function call to the arrays.
				modImports = append(modImports, modImport)
				modCalls = append(modCalls, modCall)

				if modConfig.Advanced.CustomRoutes {
					modAdvanced := make([]string, 0)
					modAdvancedIns := fmt.Sprintf("routes := %s.GetRoutes()\nfor route, handler := range routes {\n    server.AddMainRoute(route, handler)\n}", modConfig.ModNameNoSpaces)

					modAdvanced = append(modAdvanced, modAdvancedIns)
					modImports = append(modImports, "\"MT-GO/server\"")

					fmt.Println("Added Advanced calls:", modAdvancedIns)
				}
			}
		}
	}

	// Debugging: Print the generated import and function call statements.
	//fmt.Println("Generated import statements:")
	//fmt.Println(strings.Join(modImports, "\t"))

	//fmt.Println("Generated function call statements:")
	//fmt.Println(strings.Join(modCalls, "\t"))

	// Update the "mods.go" file.
	modFile := filepath.Join(modDir, "mods.go")
	fmt.Println("Updating 'mods.go' file:", modFile)
	err = updateModsFile(modFile, modImports, modCalls)
	if err != nil {
		fmt.Println("Error updating mods.go:", err)
		return
	}

	exeDir, err := os.Executable()
	if err != nil {
		fmt.Println("Error getting the executable path:", err)
		return
	}

	// Start the main Go instance in a new cmd instance.
	mainGoFile := filepath.Join(filepath.Dir(exeDir), "server.go")
	fmt.Println("Starting main Go instance:", mainGoFile)
	cmd := exec.Command("cmd", "/c", "start", "cmd", "/k", "go run "+"server.go")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	// Run the new cmd instance to start the main Go program.
	if err := cmd.Run(); err != nil {
		fmt.Println("Error starting the main Go instance:", err)
		return
	}

	// Close the updater executable.
	fmt.Println("Updater finished.")
	os.Exit(1)

}

func updateModsFile(filePath string, imports []string, calls []string) error {
	// Create the new content with updated imports and function calls.

	newContent := []byte(fmt.Sprintf(
		`
    // THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MANUALLY EDIT.
    package mods

    import (
        %s
    )

    var startTime time.Time

    func Init() {
        startTime = time.Now()
        fmt.Println("    -ModLoader-\n Initializing...")
        defer main()
    }

    func main() {
    %s
        endTime := time.Now()
        defer fmt.Printf("Done! Finished loading mods in %%s \n    -Bye Bye!-\n", endTime.Sub(startTime))
    }
    %s
    `,
		strings.Join(imports, "\n"),
		strings.Join(calls, "\n"),
	))

	// Write the updated content to "mods.go" or create the file if it doesn't exist.
	err := os.WriteFile(filePath, newContent, os.ModePerm)
	if err != nil {
		return err
	}

	return nil
}
